\chapter{Introduction}

As programs become more complicated, we have a greater need for
high-level languages which abstract away from much of the underlying
machine. A key part of such a language is a run-time \gls{memory
  management} system, and in particular the automatic disposal of
unneeded allocated memory: that is, \gls{garbage collection}.

\section{Motivation}

Garbage collection is an important part of many modern programming
languages, however there is an implicit assumption that it never goes
wrong. It would not be feasible for the programmer to account for all
the ways in which the run-time support system may fail, and doing so
would remove the benefit of using such a language in the first
place. But these systems are not perfect: they are written and tested
by humans, with formal verification being very uncommon.

An arguably better approach is to design a \gls{garbage collector}
which is then formally verified, in order to be able to definitively
eliminate all bugs from the \gls{collector}, and so release the
programmer from the possible worry of how it may fail. For total
certainty, any implementation must be proven to be a faithful
translation of the algorithm to machine code, however merely having a
verified algorithm is a good stepping-stone towards this.

\section{Goals and Contributions}

In this project, I intend to develop a flexible formalism that can be
applied to determine the correctness of a variety of types of
\glspl{garbage collector}, by firstly considering \gls{mark-sweep}
\glspl{collector} and then \gls{copying} \glspl{collector}, building
up to proofs for a \gls{collector} of each type, and then from that
deriving a more abstract and widely-applicable formalism.

\todo{Contributions}

\section{Outline}

Chapter 2 summarises the historical context and recent developments in
the field of the project are presented, and is built upon in Chapter 3
where the literature-motivated aims of the project are presented.

Chapters 4 to 6 proceed to formalise partial correctness for
garbage collection, by considering independently mark-sweep and
copying collectors, and then abstracting from the specifics of both to
produce a general formalism.

Chapter 7 develops a garbage collection algorithm, proves it
correct using the formalism, and then shows an implementation of the
algorithm in a language runtime. The relation between algorithm and
code is then discussed.

Finally, Chapters 8 and 9 summarise the contributions of the project
and what remains to be done, as well as discussing limitations of the
work.
