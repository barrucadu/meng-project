\chapter{Correctness of Copying Collectors}
\label{sec:copying}

We shall use the same definitions of the \gls{heap}
(defn. \ref{def:ms-heap}), \gls{cell} (defn. \ref{def:ms-cell}),
\gls{pointer} (defn. \ref{def:ms-pointer}), and reachability
(defn. \ref{def:ms-reachable}) as in the prior chapter. Unfortunately,
the definition of word preservation
(defn. \ref{def:ms-word-preservation}) will have to change, because a
\gls{copying} \gls{collector} renames addresses.

\section{Copying}
\label{sec:copying-copying}

Before presenting a definition of correct copying, I have to highlight
the inadequacies of the \gls{mark-sweep} word preservation. Firstly,
it does not allow for mutation of \glspl{pointer}, which is essential
for a \gls{copying} \gls{collector}, but more subtly, it does not
allow for \glspl{cell} to be relocated. This arises in the $h[w] =
h'[w]$ part of the formalism. If \glspl{cell} can be relocated, then
this makes no sense, as $w$ is a \gls{pointer}, and so $w$ in the new
\gls{heap} is not necessarily the same as $w$ in the old
\gls{heap}. Thus, we also need to be able to find old $w$ values.

\begin{definition}[Correct Copying]
  \label{def:c-correct-copying}
  After garbage collection, no allocated cells have been mutated,
  except in the pointer fields, in which case we apply an address
  translation function $f$.

  \begin{align*}
    \forall c \in h,\ \forall w \in c,\ \alloc{c} & \implies
    \mathrm{type}(w) = \mathrm{pointer} \iff h[w] = f(h'[f^{-1}(w)])\\
    &\quad\land \mathrm{type}(w) \neq \mathrm{pointer} \iff h[w] =
    h'[f^{-1}(w)]
  \end{align*}
\end{definition}

I have decided to define correct copying as a word preservation-like
property, rather than define it separately, as what is ``correct
copying'' but a way of correctly transforming the contents and
locations of \glspl{cell}, according to some rule?

\section{Address Translation}
\label{sec:copying-address}

In the definition of correct \gls{copying}, I referenced a function
$f$, to update addresses. Unfortunately, not every function will do
here. Trivially, we can see that the constant function won't work, as
then everything would be moved to the same place, resulting in data
corruption. The function needs to preserve uniqueness of
addresses. Furthermore, in order to reason about words in the original
\gls{heap}, $h'$, we need to be able to go backwards: the function
must be invertible.

I shall borrow from Myreen\cite{Myreen10} here in his formalism of $f$
as an involution,

\begin{definition}[Address Translation Function]
  \label{def:c-address-translation-function}
  The address translation function, $f$, is defined across the entire
  heap (total), preserves uniqueness (injective), and is invertible
  (surjective). Thus, $f$ is a bijective endofunction on addresses.

  In order to ease reasoning, we shall be slightly stricter than this,
  and mandate $f$ is an involution, \[f \of f = \id\]
\end{definition}

I decided to use an involution here because showing that $\forall x,\
(f \of f)~x = x$ may be easier than proving the more abstract
properties of injectivity and surjectivity. Furthermore, the function
doesn't strictly need to be total: it only needs to be defined for
words which are still allocated after collection. However, the
totality requirement enables us to use the array reasoning to build up
the function, which is useful.

If we start with $f = \id$, then we simply need to show that, for
every allocated word $w$, the \gls{garbage collector} performs $f[w] =
w'; f[w'] = w$. Furthermore, we need to show that contiguous words
within the same \gls{cell} remain in the same relative place after
copying. This could have been avoided by defining $f$ as a cell
translation function, which moves entire cells at a time, but then
this would have complicated reasoning about individual words.

Finally, we must show that the roots are correctly translated, as they
may not be correct after things have been moved,

\begin{definition}[Root Translation]
  \label{def:c-root-translation}
  \[roots = \map{f}{roots'}\]

  Where $\map{f}{xs} = \langle f(x)~|~x \in xs \rangle$.
\end{definition}

\section{Case Study: A Garbage Collector for Lisp}
\label{sec:copying-example}

Fenichel and Yochelson\cite{Fenichel69} introduced a simple semispace
copying garbage collector for lists in Lisp systems, and assume the
existence of a correct collector for atoms. The collector works by
storing in the car of each cell a flag indicating that it has been
copied, and a forwarding pointer in the cdr. This permits a very
simple algorithm, which has been recast in a Hoare-like form below:

\begin{lstlisting}
gc():
    flipconsspace()
    for each p in roots:
        p = collect(p)
    flipsemispace()

collect(p):
    if p is atomic:
        return collectatom(p)
    else if car(p) = ALREADYCOPIED:
        return cdr(p)
    else:
        a = car(p)
        b = cdr(p)
        q = cons(NIL, NIL)

        rplaca(p, ALREADYCOPIED)
        rplacd(p, q)

        nrplaca(q, collect(a))
        nrplacd(q, collect(b))

        return q
\end{lstlisting}

Firstly, it must be noted that pointers are interpreted relative to
the semispaces. A pointer $p$ refers to the location $p$ in the
current semispace. Then, there are some functions which must be
defined: \texttt{flipconsspace} causes cons allocation to happen in
the other semispace; \texttt{flipsemispace} flips the roles of the
semispaces; \texttt{collectatom} is a garbage collection function for
atoms, which we assume to be correct; \texttt{nrplaca} and
\texttt{nrplacd} are like \texttt{rplaca} and \texttt{rplacd} except
they interpret the pointer in the other semispace.

We can thus see that the collector allocates cons cells for every
reachable cons cell in the other semispace, copying over car and cdrs
as it goes, and then flips the roles of the semispaces, so that the
mutator uses the new space.

\subsection{Partial Correctness}
\label{sec:copying-example-partial}

\todo{Partial correctness: only focus on collect}

Firstly, we need to define what an ``address'' for this rather strange
system is. As pointers are interpreted relative to a semispace, each
pointer has two related memory addresses, which means we can't just
talk about $h[p]$. Let's define an address as a pair, consisting of a
semispace to interpret it in, and a pointer, $(s, p)$. Assuming the
two semispaces are contiguous, are numbered 0 and 1, and pointers
range from 0 to the size of the semispace, turning this into a numeric
address is done by the operation $s \times \mathrm{semispace\_size} +
p$. We shall proceed to use $s'$ to refer to the semispace before
garbage collection was initiated, and $s$ to refer to the current
(different) semispace.

\subsection{Total Correctness}
\label{sec:copying-example-total}

A quick read of the code will reveal that the only place in which
nontermination could possibly occur is in the recursive call in the
else clause of \texttt{collect}. However, equally obviously, we can
see that this will never happen, because the base case of the
termination is that the car of a cell is \texttt{ALREADYCOPIED}, and
as soon as we hit the else case we do that. Thus, even if we were to
encounter a cyclic structure, reaching again the point at which we
entered it would end the recursion.

\begin{proof}
  By induction on the number of uncopied and non-atomic cells in the
  semispace we are copying from.

  \begin{description}
  \item[Base case, $n = 0$] In this case, every cell is either an atom
    or is marked as having being copied, in which case there is no
    recursive call, and so \texttt{collect} terminates.

  \item[Inductive case, $n = k + 1$] We have three cases, depending on
    what the cell currently being examined is,

    \begin{description}
    \item[atom] No recursive call: terminates.
    \item[copied] No recursive call: terminates.
    \item[else] We mark the cell as copied, and \texttt{collect} makes
      the recursive call. We now have a heap where $n = k$, which by
      assumption terminates.
    \end{description}
  \end{description}

  We do not need to worry about \texttt{gc}, as the only loop in there
  is over a fixed-size list, which must necessarily terminate.
\end{proof}

\section{Summary}
\label{sec:copying-summary}

In this chapter I highlighted the differences between the formalisms
suitable for \gls{mark-sweep} and \gls{copying} \glspl{collector}:
``correct copying'' replacing word preservation, and the introduction
of ``correct translation'' for \gls{pointer} mutation during
\gls{garbage collection}.

I argued that correctness for a \gls{copying} \gls{collector} comes
down to copying exactly the \glspl{live cell} and updating all
\glspl{pointer} consistently.

I then talked about the Fenichel/Yochelson\cite{Fenichel69} collector,
and provided proofs of its partial and total correctness. These proofs
shall not be referenced in future chapters, and merely serve as an
illustration of the utility of the definition of correctness presented
here. Definitions will be reused, however, in producing an abstract
formalism of garbage collection.
