\chapter{Correctness of Copying Collectors}
\label{sec:copying}

We shall use the same definitions of the \gls{heap}
(defn. \ref{def:ms-heap}), \gls{cell} (defn. \ref{def:ms-cell}),
\gls{pointer} (defn. \ref{def:ms-pointer}), and reachability
(defn. \ref{def:ms-reachable}) as in the prior chapter. Unfortunately,
the definition of word preservation
(defn. \ref{def:ms-word-preservation}) will have to change, because a
\gls{copying} \gls{collector} renames addresses.

\section{Copying}
\label{sec:copying-copying}

Before presenting a definition of correct copying, I have to highlight
the inadequacies of the \gls{mark-sweep} word preservation. Firstly,
it does not allow for mutation of \glspl{pointer}, which is essential
for a \gls{copying} \gls{collector}, but more subtly, it does not
allow for \glspl{cell} to be relocated. This arises in the $h[w] =
h'[w]$ part of the formalism. If \glspl{cell} can be relocated, then
this makes no sense, as $w$ is a \gls{pointer}, and so $w$ in the new
\gls{heap} is not necessarily the same as $w$ in the old
\gls{heap}. Thus, we also need to be able to find old $w$ values.

\begin{definition}[Correct Copying]
  \label{def:c-correct-copying}
  After garbage collection, no allocated cells have been mutated,
  except in the pointer fields, in which case we apply an address
  translation function $f$.

  \begin{align*}
    \forall c \in h,\ \forall w \in c,\ \alloc{c} & \implies
    \mathrm{type}(w) = \mathrm{pointer} \iff h[w] = f(h'[f^{-1}(w)])\\
    &\quad\land \mathrm{type}(w) \neq \mathrm{pointer} \iff h[w] =
    h'[f^{-1}(w)]
  \end{align*}
\end{definition}

I have decided to define correct copying as a word preservation-like
property, rather than define it separately, as what is ``correct
copying'' but a way of correctly transforming the contents and
locations of \glspl{cell}, according to some rule?

\section{Address Translation}
\label{sec:copying-address}

In the definition of correct \gls{copying}, I referenced a function
$f$, to update addresses. Unfortunately, not every function will do
here. Trivially, we can see that the constant function won't work, as
then everything would be moved to the same place, resulting in data
corruption. The function needs to preserve uniqueness of
addresses. Furthermore, in order to reason about words in the original
\gls{heap}, $h'$, we need to be able to go backwards: the function
must be invertible.

I shall borrow from Myreen\cite{Myreen10} here in his formalism of $f$
as an involution,

\begin{definition}[Address Translation Function]
  \label{def:c-address-translation-function}
  The address translation function, $f$, is defined across the entire
  heap (total), preserves uniqueness (injective), and is invertible
  (surjective). Thus, $f$ is a bijection on addresses.

  In order to ease reasoning, we shall be slightly stricter than this,
  and mandate $f$ is an involution, \[f \of f = \id\]
\end{definition}

I decided to use an involution here because showing that $\forall x,\
(f \of f)~x = x$ may be easier than proving the more abstract
properties of injectivity and surjectivity. Furthermore, the function
doesn't strictly need to be total: it only needs to be defined for
words which are still allocated after collection. However, the
totality requirement enables us to use the array reasoning to build up
the function, which is useful.

If we start with $f = \id$, then we simply need to show that, for
every allocated word $w$, the \gls{garbage collector} performs $f[w] =
w'; f[w'] = w$. Furthermore, we need to show that contiguous words
within the same \gls{cell} remain in the same relative place after
copying. This could have been avoided by defining $f$ as a cell
translation function, which moves entire cells at a time, but then
this would have complicated reasoning about individual words.

\section{Case Study: A Garbage Collector for Lisp}
\label{sec:copying-example}

\todo{Slightly informal proof for Fenichel/Yochelson 
collector. Informality is ok, because this is only to show the ideas
are in the right direction.}

\section{Summary}
\label{sec:copying-summary}

In this chapter I highlighted the differences between the formalisms
suitable for \gls{mark-sweep} and \gls{copying} \glspl{collector}:
``correct copying'' replacing word preservation, and the introduction
of ``correct translation'' for \gls{pointer} mutation during
\gls{garbage collection}.

I argued that correctness for a \gls{copying} \gls{collector} comes
down to copying exactly the \glspl{live cell} and updating all
\glspl{pointer} consistently.

I then talked about the Fenichel/Yochelson\cite{Fenichel69} collector,
and provided proofs of its partial and total correctness. These proofs
shall not be referenced in future chapters, and merely serve as an
illustration of the utility of the definition of correctness presented
here. Definitions will be reused, however, in producing an abstract
formalism of garbage collection.
