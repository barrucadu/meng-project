\chapter{Partial Correctness for Garbage Collection}
\label{sec:gc}

In this chapter, I shall produce a general correctness criteria for
garbage collection, and show how it can be applied. I shall do this by
first comparing the mark-sweep and copying formalisms, and abstracting
the commonalities from both. Definitions shall be reused, but
specifics of the proofs shall not be.

As proving a very abstract correctness criteria holds for a concrete
implementation may be difficult, I shall provide a ``framework'' for
proof: a collection of simpler obligations which, together, are
sufficient for correctness. I shall then conclude by briefly
discussing how the formalism could possibly be extended to apply to
collectors other than the stop-the-world type.

\section{Comparison of Mark-Sweep and Copying Correctness}
\label{sec:gc-comparison}

Many of the definitions created for the mark-sweep correctness were
re-used by the copying correctness. The changes were strict
generalisations, and were required because the copying collector moves
cells around, whereas the mark-sweep collector does not. Despite these
changes, the core idea behind correct garbage collection: that it is
a transformation on the heap which produces an output heap of the same
`shape' and data, but with no garbage, remained the same. All that
changed is how this was achieved.

However, the mark-sweep correctness very naturally decomposes into
correct marking and correct sweeping, whereas there was no such
similar decomposition for the copying correctness. This showed in the
proofs, where the loop invariant for the mark-sweep collector dealt
with both cases, but the invariant for the copying collector had to
consider the entire state at once.

Despite this apparent difference, as the decomposition arises from
combining the domain-specific knowledge of how a mark-sweep collector
works with the notion of what correct garbage collection entails, I
don't think that this difference is relevant at this more abstract
level.

Setting aside the decomposition, I believe that the mark-sweep
correctness can apply to any non-moving collector, and the copying
correctness to any moving collector. This is because the only
mark-sweep-specific part of the mark-sweep correctness is the mark
flag, but this is unset before and after collection, and so other
non-moving collectors can be used by disregarding it, and then not
making use of the decomposition. Furthermore, the copying correctness
makes no reference to semispaces, and only requires that addresses get
updated consistently, and so it can be applied to any moving
collector.

\section{Correct Garbage Collection}
\label{sec:gc-correct}

As we have notions of correctness for both moving and non-moving
correctness, and given that a non-moving collector can be seen as a
special case of a moving collector where the translation function is
the identity, I believe that the copying correctness, with a slight
extension to allow garbage collection metadata, expresses a notion of
correct garbage collection in general, at least for stop-the-world
collectors. I shall reiterate all of the definitions used, and
highlight the changes that must be made.

From the mark-sweep collector, we re-use the definitions of the heap,
cells, pointers, the live cell invariant, and reachability
(defns. \ref{def:ms-heap}, \ref{def:ms-cell}, \ref{def:ms-pointer},
\ref{def:ms-live-cell-invariant}, and \ref{def:ms-reachable}).

From the copying collector, we re-use the definitions of cell IDs,
allocation, the address translation function, and root translation
(defns. \ref{def:c-cell-id}, \ref{def:c-allocation},
\ref{def:c-address-translation-function}, and
\ref{def:c-root-translation}).

Word preservation (correct copying)
(defns. \ref{def:ms-word-preservation} and
\ref{def:c-correct-copying}) are redefined to allow for the
possibility of mutated metadata words
(defn. \ref{def:g-preservation}).

\begin{definition}[Preservation]
  \label{def:g-preservation}
  After garbage collection, data words have not been mutated, pointers
  have been remapped consistently, and garbage collection metadata may
  have been mutated (but in a way which still obeys any other
  invariants or postconditions, of course).

  \begin{align*}
    \forall c \in h,\ \forall w \in c,\ &\alloc{c} \implies
    \left(\mathrm{type}(w) = \mathrm{pointer} \iff h[w] = f(h'[f^{-1}(w)])\right.\\
    &\quad\quad\quad\quad \land \mathrm{type}(w) = \mathrm{data}
    \iff h[w] = h'[f^{-1}(w)]\\
    &\quad\quad\quad\quad \left.\lor \mathrm{type}(w) = \mathrm{gc}\right)\\
    &\land \alloc{c} \iff c \in \reach{h'}{r'}
  \end{align*}
\end{definition}

To apply this to the mark-sweep collector, we simply take $f = \id$,
let there be one metadata word, and have a pre- and post-condition
that it be set to ``unmarked''. The collector may break this condition
in the middle, and does so: this allows the separation of reasoning
about the marking and sweeping phases. To apply this to the copying
collector, we see that this is identical to what we already had if
there are no metadata words.

\section{A Framework for Proof}
\label{sec:gc-framework}

In this section, I shall outline the stages that all garbage
collectors follow, and then provide proof obligations for each which,
taken together, show correctness.

\subsection{Stages of Garbage Collection}
\label{sec:gc-framework-stages}

By combining the mark-sweep and copying collectors, we can see that
a garbage collector performs the following operations, although some
may only be implicit,

\begin{description}
  \item[Identify all roots] strictly speaking, this isn't a part of
    the garbage collector, but it is a precondition of all collectors,
    and so I have included it here.

  \item[Identify preserved cells] specifically, the collector
    identifies a subset of all the allocated cells to preserve, and
    for correctness, this should be the same as the set of live
    cells. In the mark-sweep collector, this is the marking phase, in
    the copying collector this is done implicitly whilst copying.

  \item[Preserve identified cells] cells are moved to their new
    locations, and pointers updated. In a non-moving collector,
    nothing happens here.

  \item[Free non-preserved cells] this in practice would consist of
    building a free list.

  \item[Clean up] Any housekeeping data used by the collector, such as
    mark flags, is now reset to a state which will meet the
    preconditions of the collector when it is next called.
\end{description}

I believe that this outline is general enough to apply to any
stop-the-world collector.

\subsection{Proof Obligations}
\label{sec:gc-framework-obligations}

\todo{Proof obligations for each stage}

\subsection{Sufficiency of the Framework}
\label{sec:gc-framework-sufficiency}

\todo{Proof that the framework works}

\section{Less Strict Collectors}
\label{sec:gc-lessstrict}

\todo{Discussion of assumptions (stop-the-world)}

\subsection{Incremental Garbage Collection}
\label{sec:gc-lessstrict-incremental}

\todo{Transformation to stop-the-world and proof. Remaining out of
  scope proof obligation (all valid interleavings work)}

\subsection{Generational Garbage Collection}
\label{sec:gc-lessstrict-generational}

\todo{Generations are subheaps for minor-collection
  correctness. Normal proof for major-collection correctness.}
