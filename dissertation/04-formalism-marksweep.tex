\chapter{Correctness of Mark-Sweep Collectors}

In this chapter, I shall talk about the necessary formalisms and proof
obligations for \gls{mark-sweep} \glspl{collector}, building up to a
proof of the Armstrong/Virding\cite{Armstrong95} \gls{collector}.

\begin{definition}[Heap]
  The heap is an array of words in the form (type, data).
\end{definition}

Firstly, we need a \gls{heap}. I shall adopt the convention that the
\gls{heap} is a flat array, and so \glspl{pointer} are just indexes
into this array (or NULL). This allows me to use Gries' array
formalism\cite{Gries87}, which models arrays as functions; thus
simplifying the reasoning needed when dealing with potential
side-effects. Furthermore, type data is needed for each word, as there
must be some way of distinguishing \gls{pointer} data from non-pointer
data, and establishing where the \gls{garbage collector} metadata
lies. It may seem that needing to tag every single word with a type is
wasteful, but in the case where the \gls{collector} is able to
determine this automatically, the type can be ``stored'' as a ghost
variable.

\begin{definition}[Cell]
  A cell is a contiguous sequence of one or more words in the heap,
  one of which is the garbage collection metadata word. Metadata words
  precede data words, forming a header.
\end{definition}

Next we move on to \glspl{cell}. I have ruled out the possibility of
fragmented \glspl{cell}, as this can always be modelled by smaller
\glspl{cell} which point to each other (and this is really the only
way that fragmentation could even be implemented). I have reserved an
entire word for the use of the \gls{garbage collector}, but this is
quite generous, and in practice would be reduced as much as
possible. This reservation simplifies proofs, and can be worked around
in practice by transforming a more efficient \gls{garbage collector}
into a less efficient one, and then performing the proof: if the
transformation is correct, the proof will hold for the original,
albeit with slightly different space characteristics.

Now we'll define a couple of helper functions which will be of use
later on: given a \gls{pointer}, $p$, let $\gchead{p}$ return a pointer to the
\gls{garbage collection} metadata word in its header, and let
$\alloc{p}$ be true if and only if the \gls{cell} has been allocated.

\begin{definition}[Pointer]
  A pointer is an index into the heap array, or a special value
  ``null''. If non-null, a pointer points to the start of the data
  section (end of the header) of a cell.
\end{definition}

I have restricted \glspl{pointer} to only pointing at the start of the
data portion of a \gls{cell}, as then going from an internal
\gls{pointer} to a cell header does not need to be considered at all,
furthermore, in practice the \gls{mutator} does not need to know about
the metadata, and should not know: it should be for purely internal
use. If the size and layout of the header is known in advance, any
word in it can be accessed by \gls{pointer} arithmetic.

\section{Marking}

In this section I shall attack the problem of correct marking, firstly
as a problem in graph theory, and then as a more concrete problem when
dealing with an array of memory with pointers.

Let's start out by saying exactly what goes in that \gls{garbage
  collection} metadata word. It is a mark flag, equal to 0 if the
\gls{cell} has not been marked, and any other value if it has.

\begin{definition}[Reachable]
  A cell is reachable if it is pointed to by a root, or pointed to by
  a cell which is reachable.

  \begin{minipage}{.5\textwidth}
    \begin{prooftree}
      \AxiomC{$r \in roots$}
      \AxiomC{$r \pointsto a$}
      \BinaryInfC{$a \in \reach{h}{roots}$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.5\textwidth}
    \begin{prooftree}
      \AxiomC{$a \in \reach{h}{roots}$}
      \AxiomC{$a \pointsto b$}
      \BinaryInfC{$b \in \reach{h}{roots}$}
    \end{prooftree}
  \end{minipage}

  The notation $a \pointsto b$ means that $a$ points to the cell $b$.
\end{definition}

If we abandon our array-based interpretation of memory for the moment,
and instead consider the \gls{heap} to be a digraph of \glspl{cell}
connected by \glspl{pointer}, then reachabilty can be defined
inductively over the nodes of the graph very simply, and this lends
itself to implementation with a recursive function. If we denote the
set of all marked (and allocated) cells by $\markset{h}{roots}$, then
what we want after marking is $\markset{h}{roots} = \reach{h}{roots}$.

Returning to the array formalism, what we thus want from a marker is
the following property:

\begin{definition}[Correct Marking]
  After marking, for all allocated \glspl{cell}, the mark flag is
  unset if and only if the \gls{cell} is not reachable.

  \[\forall c \in h,\ \alloc{c} \implies
  \left(h\left[\gchead{c}\right] = 0 \iff c \notin
    \reach{h}{roots}\right)\]
\end{definition}

Note that this does not say anything about unallocated
\glspl{cell}. An unallocated \gls{cell} can contain any garbage, but
then it is the job of the allocator to clean it up before handing it
out to the \gls{mutator}. An alternative formulation would be
$\alloc{c} \iff \left(\ldots\right)$, but this would then require the
\gls{garbage collector} to unset the mark flag of any \gls{cell} it
frees, and as \glspl{cell} need to be ``cleaned up'' before being
given to the \gls{mutator} anyway, confining this to the allocator
seems reasonable.

As we'll be referring to the property ``is marked'' multiple times,
let's define a shorthand, $\marked{h, c} \iff h\left[\gchead{c}\right]
\neq 0$.

\section{Sweeping}

\todo{Proof obligations for sweeping, and how they may be discharged}

In this section I shall consider sweeping, with an assumption that
correct marking has already been performed. Specifically, I shall
approach the problem by assuming that the goal of a sweeper is to
partition the allocated cells into a ``live'' and a ``free'' list,
where the live list is just what was reachable in memory
before. Finally, I shall talk a little about interleaved marking and
sweeping, such as happens in some incremental and other special-case
collectors.

\todo{Keep set. (Implicit) Free list. Unmarking.}

\subsection{Interleaved Marking and Sweeping}

\todo{Note on obligations arising from interleaving}

In this subsection I shall talk about how sweeping and marking can be
interleaved, having assumed in the prior sections that they are done
one after the other.

\section{Case Study: A Garbage Collector for Erlang}

Armstrong and Virding\cite{Armstrong95} introduce a simple
\gls{mark-sweep} \gls{collector} for Erlang, making use of the
immutability of the language in order to combine the mark and sweep
stages. The \gls{collector} operates on a \gls{heap} of cons cells,
and uses a \gls{pointer} \texttt{SCAV} to keep track of the current
position of the \gls{collector} in the heap.

The algorithm is as follows:

\begin{lstlisting}
last = current
SCAV = hist(last)
while (SCAV != first) {
    if (marked(SCAV)) {
        possibly_mark(car(SCAV));
        possibly_mark(cdr(SCAV));
        unmark(SCAV);
        last = SCAV;
        SCAV = hist(last);
    } else {
        tmp = SCAV;
        SCAV = hist(SCAV);
        set_history(last, SCAV);
        free_cons(tmp);
    }
}
\end{lstlisting}

\todo{Recast in the array formalism. Include the allocator. Specify
  the behaviour of all functions.}

The \texttt{possibly\_mark} function follows and marks its argument if
it is a pointer; \texttt{first} and \texttt{current} point to the
first and last allocated \glspl{cell}; the \texttt{hist} function
returns a \gls{pointer} to the \gls{cell} allocated before its
argument. It is assumed that all cells pointed to by roots have been
marked before calling the collector.

This \gls{collector} works because the history fields form a linked
list of allocated cells, going back to the beginning of time. As the
language is immutable, pointers must always point back in time, and so
if a cell is unmarked by the time it is reached (by following the
history list), then it must be garbage.

We can express this as a loop invariant: the portion of the heap which
has been considered consists only of unmarked, reachable cells.

\subsubsection{Partial Correctness}

Let $\id~x$ be the ``allocation ID'' of a cell $x$. The first cell has
an ID of 0, and the ID of every other cell is 1 + the ID of the
previously allocated cell.

We can then express the loop invariant as follows:

\[\forall x,\ \id~x > \id~\mathtt{SCAV} \implies
\lnot \mathrm{marked}~x \land x \in \reach{h}{roots}\]

The astute reader will notice that this says nothing about the first
cell. This is because the collector contains no machinery to alter
which cell is considered the ``first'' cell, and so cannot free it.

\todo{Proof}

\subsubsection{Total Correctness}

We can use allocation IDs to express that the history list forms an
unbroken chain of cells, all the way back to the first cell, as
follows:

\[\forall x,\ \left(x = \mathrm{first} \implies x =
  \mathrm{hist}(x)\right) \land \left(x \neq \mathrm{first} \implies
  \exists n \in \mathbb N_{1},\ \id~x = n + \id~\mathrm{hist}(x)\right)\]

The loop condition can be restated as $\id~\mathtt{SCAV} \neq 0$. As
there are no IDs below 0 ($\mathrm{hist}(\mathrm{first}) =
\mathrm{first}$), that can be further rewritten to $\id~\mathtt{SCAV}
> 0$. \texttt{SCAV} starts out as the last-allocated cell, and so has
an ID $\geq 0$. Now, in order to prove termination, we simply need to
show that $\id~\mathtt{SCAV}$ decreases at every iteration of the
loop.

To simplify, let us throw away everything which does not relate to
mutating \texttt{SCAV}, giving the following loop:

\begin{lstlisting}
while (SCAV != first) {
    if (marked(SCAV)) {
        last = SCAV;
        SCAV = hist(last);
    } else {
        SCAV = hist(SCAV);
    }
}
\end{lstlisting}

Substituting variables, we get

\begin{lstlisting}
while (SCAV != first) {
    if (marked(SCAV)) {
        SCAV = hist(SCAV);
    } else {
        SCAV = hist(SCAV);
    }
}
\end{lstlisting}

And then we can eliminate the if statement:

\begin{lstlisting}
while (SCAV != first) {
    SCAV = hist(SCAV);
}
\end{lstlisting}

Trivially, we can now see that there are two cases:

\begin{description}
  \item[Case 1, $\mathtt{SCAV} = \mathrm{first}$] In this case,
    $\mathrm{hist}(\mathtt{SCAV}) = \mathtt{SCAV}$, and so
    $\id~\mathtt{SCAV}$ does not decrease, but this situation is
    precisely the loop termination condition.

  \item[Case 2, $\mathtt{SCAV} \neq \mathrm{first}$] In this case, we
    know by the history list assumption that
    $\id~\mathrm{hist}(\mathtt{SCAV}) < \id~\mathtt{SCAV}$, and so
    $\id~\mathtt{SCAV}$ does decrease. Furthermore, we know that the
    ID cannot decrease below zero, and so we get a strictly decreasing
    sequence of positive natural numbers. Clearly, this sequence is
    not infinite, and so the loop terminates.
\end{description}

\section{Summary}

\todo{Quick recap of formalism, proof obligations, and proof.}