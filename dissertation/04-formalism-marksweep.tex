\chapter{Correctness of Mark-Sweep Collectors}
\label{sec:marksweep}

In this chapter, I shall talk about the necessary formalisms and proof
obligations for \gls{mark-sweep} \glspl{collector}, building up to a
proof of the Armstrong/Virding\cite{Armstrong95} \gls{collector}.

\begin{definition}[Heap]
  \label{def:ms-heap}
  The heap is an array of words in the form (type, data).
\end{definition}

Firstly, we need a \gls{heap}. I shall adopt the convention that the
\gls{heap} is a flat array, and so \glspl{pointer} are just indexes
into this array. This allows me to use Gries' array
formalism\cite{Gries87}, which models arrays as functions; thus
simplifying the reasoning needed when dealing with potential
side-effects. Furthermore, type data is needed for each word, as there
must be some way of distinguishing \gls{pointer} data from non-pointer
data. It may seem that needing to tag every single word with a type is
wasteful, but in the case where the \gls{collector} is able to
determine this automatically, the type can be ``stored'' as a ghost
variable.

\begin{definition}[Cell]
  \label{def:ms-cell}
  A cell is a contiguous sequence of one or more words in the heap,
  starting with a sequence of one or more metadata words used by the
  garbage collector.
\end{definition}

Next we move on to \glspl{cell}. I have ruled out the possibility of
fragmented \glspl{cell}, as these can always be modelled by smaller
\glspl{cell} which point to each other (and this is really the only
way that fragmentation could even be implemented). I have reserved at
least an entire word for the use of the \gls{garbage collector}, but
this is quite generous, and in practice would be reduced as much as
possible. This reservation simplifies proofs, and can be worked around
in practice by transforming a more efficient \gls{garbage collector}
into a less efficient one, and then performing the proof: if the
transformation is correct, the proof will hold for the original,
albeit with slightly different space characteristics.

Now we'll define a couple of helper functions which will be of use
later on: given a \gls{pointer}, $p$, let $\gchead{p}$ return a
pointer to the start of the \gls{garbage collection} metadata, and let
$\alloc{p}$ be true if and only if the \gls{cell} has been allocated.

\begin{definition}[Pointer]
  \label{def:ms-pointer}
  A pointer is an index into the heap array, pointing to the start of
  the data section (end of the header) of a cell.
\end{definition}

I have restricted \glspl{pointer} to only pointing at the start of the
data portion of a \gls{cell}, as then going from an internal
\gls{pointer} to a cell header does not need to be considered at all,
furthermore, in practice the \gls{mutator} does not need to know about
the metadata, and should not know: it should be for purely internal
use. If the size and layout of the header is known in advance, any
word in it can be accessed by \gls{pointer} arithmetic.

\begin{definition}[Word Preservation]
  \label{def:ms-word-preservation}
  After garbage collection, no allocated cells have been mutated.

   \[\forall c \in h,\ \forall w \in c,\ \alloc{c} \implies h[w] =
   h'[w]\]

   Here $h'$ refers to the state of $h$ before garbage collection
   began, and $\forall w \in c$ ranges $w$ over the indices of the
   non-header words in the cell.
\end{definition}

This is a necessary property of an entire mark-sweep collector, but
may be broken by the marker or the sweeper, as long as it is restored
at the end. As such, I have not included it in the definitions of
correctness in the following two sections, but it is still essential.

\section{Marking}
\label{sec:marksweep-marking}

In this section I shall attack the problem of correct marking, firstly
as a problem in graph theory, and then as a more concrete problem when
dealing with an array of memory with pointers.

Let's start out by saying exactly what goes in that \gls{garbage
  collection} metadata. The first word is a mark flag, equal to 0 if
the \gls{cell} has not been marked, and any other value if it has.

\begin{definition}[Reachable]
  \label{def:ms-reachable}
  A cell is reachable if it is pointed to by a root, or pointed to by
  a cell which is reachable.

  \begin{minipage}{.5\textwidth}
    \begin{prooftree}
      \AxiomC{$r \in roots$}
      \AxiomC{$r \pointsto a$}
      \BinaryInfC{$a \in \reach{h}{roots}$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.5\textwidth}
    \begin{prooftree}
      \AxiomC{$a \in \reach{h}{roots}$}
      \AxiomC{$a \pointsto b$}
      \BinaryInfC{$b \in \reach{h}{roots}$}
    \end{prooftree}
  \end{minipage}

  The notation $a \pointsto b$ means that $a$ points to the cell $b$.
\end{definition}

If we abandon our array-based interpretation of memory for the moment,
and instead consider the \gls{heap} to be a digraph of \glspl{cell}
connected by \glspl{pointer}, then reachabilty can be defined
inductively over the nodes of the graph very simply, and this lends
itself to implementation with a recursive function. If we denote the
set of all marked (and allocated) cells by $\markset{h}{roots}$, then
what we want after marking is $\markset{h}{roots} = \reach{h}{roots}$.

Returning to the array formalism, what we thus want from a marker is
the following property:

\begin{definition}[Correct Marking]
  \label{def:ms-correct-marking}
  After marking, for all allocated \glspl{cell}, the mark flag is
  unset if and only if the \gls{cell} is not reachable.

  \[\forall c \in h,\ \alloc{c} \implies
  \left(h\left[\gchead{c}\right] = 0 \iff c \notin
    \reach{h}{roots}\right)\]
\end{definition}

Note that this does not say anything about unallocated
\glspl{cell}. An unallocated \gls{cell} can contain any garbage, but
then it is the job of the allocator to clean it up before handing it
out to the \gls{mutator}. An alternative formulation would be
$\alloc{c} \iff \left(\ldots\right)$, but this would then require the
\gls{garbage collector} to unset the mark flag of any \gls{cell} it
frees, and as \glspl{cell} need to be ``cleaned up'' before being
given to the \gls{mutator} anyway, confining this to the allocator
seems reasonable.

As we'll be referring to the property ``is marked'' multiple times,
let's define a shorthand, $\marked{h}{c} \iff h\left[\gchead{c}\right]
\neq 0$.

\section{Sweeping}
\label{sec:marksweep-sweeping}

In this section I shall consider sweeping, with an assumption that
correct marking has already been performed. Then, I shall talk a
little about interleaved marking and sweeping, such as happens in some
incremental and other special-case collectors.

What do we mean when we say a sweeper is ``correct''? After a little
thought, we will realise that we mean it doesn't deallocate any
\glspl{cell} which were marked, and it unmarks all of the
\glspl{cell}. In the case of a correct marker, this is equivalent to
preserving and unmarking exactly the reachable \glspl{cell}, which
(with the constraint of word preservation) is exactly what we want our
\gls{collector} to do.

\begin{definition}[Correct Sweeping]
  \label{def:ms-correct-sweeping}
  All cells which are marked are preserved and unmarked, no garbage
  cells are preserved, and nothing other than the garbage collector
  metadata gets mutated.

  \[\forall c \in h',\ \left(\alloc{c} \iff c \in
    \markset{h'}{roots}\right) \land \left(\alloc{c} \implies
    \lnot\marked{h}{c}\right)\]
\end{definition}

The essential component here is the $\iff$, the effect of which is to
identify the set of allocated cells with the set of cells which were
marked.

\subsection{Interleaved Marking and Sweeping}
\label{sec:marksweep-sweeping-interleaved}

I have hitherto assumed that marking happens in its entirety, and then
sweeping happens in its entirety. However, sometimes marking and
sweeping are interleaved, such that in each iteration of the collector
a little more of each is done.

In order for correctness to hold here, we can conceptually separate it
out into a marker and a sweeper, but rather than talking about the
entire heap, we talk about the subheap considered so far. Thus, the
correctness of each remains the same, but we have an additional proof
obligation.

\begin{definition}[Interleaved Marking/Sweeping Correctness]
  \label{def:ms-interleaved}
  When the ``sweeper'' considers a cell, the ``marker'' has already
  marked it and everything it points to (if it was reachable).
\end{definition}

Thus, the ``marker'' always remains ahead of the ``sweeper'', and so
no problems arise. In fact, we could consider normal \gls{mark-sweep}
\glspl{collector} a special case of this, where this property
trivially holds.

\section{Case Study: A Garbage Collector for Erlang}
\label{sec:marksweep-example}

Armstrong and Virding\cite{Armstrong95} introduce a simple
\gls{mark-sweep} \gls{collector} for Erlang, making use of the
immutability of the language in order to combine the mark and sweep
stages. The \gls{collector} operates on a \gls{heap} of cons cells,
and uses a \gls{pointer} \texttt{SCAV} to keep track of the current
position of the \gls{collector} in the heap.

The algorithm is as follows:

\begin{lstlisting}
last = current
SCAV = hist(last)
while (SCAV != first) {
    if (marked(SCAV)) {
        possibly_mark(car(SCAV));
        possibly_mark(cdr(SCAV));
        unmark(SCAV);
        last = SCAV;
        SCAV = hist(last);
    } else {
        tmp = SCAV;
        SCAV = hist(SCAV);
        set_history(last, SCAV);
        free_cons(tmp);
    }
}
\end{lstlisting}

The \texttt{possibly\_mark} function follows and marks its argument if
it is a pointer; \texttt{first} and \texttt{current} point to the
first and last allocated \glspl{cell}; the \texttt{hist} function
returns a \gls{pointer} to the \gls{cell} allocated before its
argument. It is assumed that all cells pointed to by roots have been
marked before calling the collector.

This \gls{collector} works because the history fields form a linked
list of allocated \glspl{cell}, going back to the beginning of
time. As the language is immutable, \glspl{pointer} must always point
back in time, and so if a \gls{cell} is unmarked by the time it is
reached (by following the history list), then it must be
\gls{garbage}.

We can express this as a \gls{loop invariant}: the portion of the
\gls{heap} which has been considered consists only of unmodified,
reachable \glspl{cell}, and all \glspl{cell} which are directly
reachable from a \gls{cell} in the considered region are marked.

\subsubsection{Partial Correctness}
\label{sec:marksweep-example-partial}

Let $\id~x$ be the ``allocation ID'' of a cell $x$. The first cell has
an ID of 0, and the ID of every other cell is 1 + the ID of the
previously allocated cell.

We can then express the \gls{loop invariant} as follows:

\begin{align*}
  \forall c \in h',\ \forall w \in c,\ &first \in \reach{h'}{c} \land
  \id~c \geq \id~\mathtt{SCAV} \implies (\alloc{c} \iff c \in
  \reach{h'}{roots})\\
  &\quad\land (\alloc{c} \implies h[w] = h'[w] \land \lnot
  \marked{h}{c})\\
  &\quad\land (\alloc{c} \land \id~c \geq \id~\mathtt{SCAV} \implies
  (\forall c \pointsto x,\ \id~x < \id~\mathtt{SCAV} \implies
  \marked{h}{x}))
\end{align*}

As the \gls{collector} never touches the ``first'' \gls{cell}, in
order for there to be no \gls{garbage} left over at the end, then it
must necessarily be reachable. This is somewhat unusual, and arises
purely because this \gls{collector} arguably has a bug, in that this
one \gls{cell} of \gls{garbage} can survive a collection.

Let's begin by rewriting the algorithm in terms of arrays, and expand
out all of the functions within it. Furthermore, let's say that a cell
in this scheme consists of two words of metadata and two of data,
arranged in the order $\langle mark,\ history,\ car,\ cdr \rangle$.

\begin{lstlisting}
last = current
SCAV = h[gchead(last) + 1]
while (SCAV != first) {
    if (marked(h, SCAV)) {
        car = h[SCAV];
        cdr = h[SCAV + 1];

        if(type(car) == pointer) {
            h[gchead(car)] = 1
        } else {
            skip
        };

        if(type(cdr) == pointer) {
            h[gchead(cdr)] = 1
        } else {
            skip
        };

        h[gchead(SCAV)] = 0;

        last = SCAV;
        SCAV = h[gchead(last) + 1];
    } else {
        tmp = SCAV;
        SCAV = h[gchead(SCAV) + 1];
        h[gchead(last) + 1] = SCAV;
        dealloc(tmp);
    }
}
\end{lstlisting}

I have replaced \texttt{free\_cons} with \texttt{dealloc}, as it more
closely reflects what happens. The \gls{cell} in question is no longer
considered to be allocated. Allocation is being tracked through an
implicit ghost variable attached to each cell.

Combining the correct marking, correct sweeping, and word preservation
requirements, we arrive at the following postcondition for a correct
\gls{garbage collector}: \[\forall c \in h',\ \forall w \in c,\
(\alloc{c} \iff c \in \reach{h'}{roots}) \land (\alloc{c} \implies
h[w] = h'[w] \land \lnot\marked{h}{c})\]

\todo{Proof}

\begin{lemma}[Loop Invariant]
  Firstly, let's show the sufficiency of the loop invariant:

  \begin{align*}
    \forall c \in h',\ \forall w \in c,\ 
    &\mathtt{SCAV} = first \land first \in \reach{h'}{c} \land
    \id~c \geq \id~\mathtt{SCAV} \implies (\alloc{c} \iff c \in
    \reach{h'}{roots})\\
    &\quad\land (\alloc{c} \implies h[w] = h'[w] \land \lnot
    \marked{h}{c})\\
    &\quad\land (\alloc{c} \land \id~c \geq \id~\mathtt{SCAV} \implies
    (\forall c \pointsto x,\ \id~x < \id~\mathtt{SCAV} \implies
    \marked{h}{x}))\\
%
    \forall c \in h',\ \forall w \in c,\ 
    &\id~c \geq first \in \reach{h'}{c} \land \id~first
    \implies (\alloc{c} \iff c \in \reach{h'}{roots})\\
    &\quad\land (\alloc{c} \implies h[w] = h'[w] \land \lnot
    \marked{h}{c})\\
    &\quad\land (\alloc{c} \land \id~c \geq \id~\mathtt{SCAV} \implies
    (\forall c \pointsto x,\ \id~x < \id~first \implies
    \marked{h}{x}))\\
%
    \forall c \in h',\ \forall w \in c,\ 
    &(\alloc{c} \iff c \in \reach{h'}{roots}) \land (\alloc{c}
    \implies h[w] = h'[w] \land \lnot \marked{h}{c})
  \end{align*}

  Now, we have to show it holds:

  \begin{prooftree}
    \AxiomC{$\htriple{I \land C \land M}{\ldots}{I}$}
    \AxiomC{$\htriple{I \land C \land \lnot M}{\ldots}{I}$}
    \BinaryInfC{$\htriple{I \land C}{if(marked(h, SCAV)) \ldots}{I}$}
    \UnaryInfC{$\htriple{I}{while \ldots}{I \land \lnot C}$}
  \end{prooftree}

  where $C = \mathtt{SCAV} \neq first$ and $M =
  \marked{h}{\mathtt{SCAV}}$.

  This naturally separates into two cases, one for each branch of the
  if statement. These are proven separately in lemmata \ref{lem:lia}
  and \ref{lem:lib}.
  \label{lem:li}
\end{lemma}

\begin{lemma}[Loop Invariant (first branch)]
  Knowing that nothing in this branch deallocates cells, we can
  immediately simplify the proof goals to these three conditions:

  \begin{enumerate}
    \item $\mathtt{SCAV} \in \reach{h'}{roots}$
    \item $\forall w \in \mathtt{SCAV},\ h[w] = h'[w] \land
      \lnot\marked{h}{\mathtt{SCAV}}$
    \item $\forall \mathtt{SCAV} \pointsto x,\ \marked{h}{x}$
  \end{enumerate}

  Firstly, let's look at the two expansions of \texttt{possibly\_mark},
  as they are almost identical. Let's refer to the variable holding
  the possible pointer as $x$, and let $X \iff type(x) = pointer$.

  \begin{prooftree}
    \AxiomC{$\htriple{X \land P}{h[gchead(x)] = 1}{Q}$}

    \AxiomC{$\lnot X \land P \implies Q$}
    \UnaryInfC{$\htriple{\lnot X \land
        P}{skip}{Q}$}
    \BinaryInfC{$\htriple{P}{if(type(x) == pointer) \{ \ldots \} else \{
          skip \}}{Q}$}
  \end{prooftree}

  The desired postcondition, of course, is \[(type(x) = pointer \land
  \id~x < \id~SCAV) \implies \marked{h}{x}\]

  Fortunately, we know that if $x$ is a pointer, then the allocation
  ID of its \gls{cell} must be lower than that of the current
  \gls{cell} because of the constraint over the entire system: data is
  immutable. Thus, only backward pointers are possible, and so we can
  simplify the postcondition to just \[type(x) = pointer \implies
  \marked{h}{x}\]

  If $x$ is a pointer, then it gets marked. If we fill in the gaps in
  the proof tree as follows, then we can achieve this:

  \begin{align*}
    P &\iff type(x) = pointer \implies \marked{(h; \gchead{x}:1)}{x}\\
    Q &\iff type(x) = pointer \implies \marked{h}{x}
  \end{align*}

  Now we must just show that the assignment works:

  \begin{align*}
    (X \land P)[h/(h; \gchead{x}:1)] &\iff (type(x) = pointer\\
    &\quad\land (type(x) = pointer \implies \marked{(h;
      \gchead{x}:1)}{x}))\\
    &\quad[h/(h; \gchead{x}:1)]\\
%
    &\iff type(x) = pointer \land (type(x) = pointer \implies
    \marked{h}{x})\\
%
    &\implies Q
  \end{align*}

  We can now see that by simply combining lines 5 to 18, we end up in
  the state, \[(type(car) = pointer \implies \marked{h}{car}) \land
  (type(cdr) = pointer \implies \marked{h}{cdr})\] which is exactly
  what we want. We have just handled part (3) of the invariant.

  We can now inductively apply this result, combined with the
  precondition of this entire block, $\marked{h}{\mathtt{SCAV}}$ to
  trivially see that part (1) holds.

  Finally, we can see that we never assign to anything other than the
  mark flags, and the mark flag of \texttt{SCAV} is unset on line 20,
  and so part (2) holds.
  \label{lem:lia}
\end{lemma}

\begin{lemma}[Loop Invariant (second branch)]
  \todo{Symbolify this}

  As we have assumed correct marking, we know that this cell is not
  reachable from the roots. The invariant is broken on line 26, as an
  unreachable cell is left in the list ahead of \texttt{SCAV}, but
  then it is restored in lines 27 and 28, as the cell is removed and
  deallocated. Thus, the invariant still holds.
  \label{lem:lib}
\end{lemma}

\begin{proof}
  Knowing that the loop invariant holds and is sufficient for
  correctness, as established by lemma \ref{lem:li}, it only remains
  to be shown that it holds at the start of the loop.

  \begin{prooftree}
    \AxiomC{$\htriple{I''}{last = current}{I'}$}
    \AxiomC{$\htriple{I'}{\texttt{SCAV} = h[gchead(last) + 1]}{I}$}
    \BinaryInfC{$\htriple{I''}{last = current; \texttt{SCAV} = h[gchead(last) + 1]}{I}$}
  \end{prooftree}

Furthermore, as $h$ refers to the current heap and $h'$ to the
original heap (being a ghost variable), and as the heap has not been
mutated yet, $h = h'$, which allows further simplifications to be made.

  \begin{align*}
    I' &= I[h[\gchead{last} + 1] / \mathtt{SCAV}]\\
%
    &= \forall c \in h,\ first \in \reach{h}{c}\\
    &\quad\land \id~c \geq \id~h[\gchead{last} + 1] \implies
    (\alloc{c} \iff c \in \reach{h}{roots})\\
    &\quad\land (\alloc{c} \implies \lnot \marked{h}{c})\\
    &\quad\land (\alloc{c} \land \id~c \geq \id~h[\gchead{last}+1] \implies\\
    &\quad(\forall c \pointsto x,\ \id~x < \id~h[\gchead{last} + 1]
    \implies \marked{h}{x}))\\\\
%
    I'' &= I'[current / last]\\
    &= \forall c \in h,\ first \in \reach{h}{c}\\
    &\quad\land \id~c \geq \id~h[\gchead{current} + 1] \implies
    (\alloc{c} \iff c \in \reach{h}{roots})\\
    &\quad\land (\alloc{c} \implies \lnot
    \marked{h}{c})\\
    &\quad\land (\alloc{c} \land \id~c \geq \id~h[\gchead{current}+1]
    \implies\\
    &\quad(\forall c \pointsto x,\ \id~x < \id~h[\gchead{current} + 1]
    \implies \marked{h}{x}))\\
%
    &= \forall c \in h,\ first \in \reach{h}{c} \land (\alloc{c}
    \implies \lnot \marked{h}{c})
  \end{align*}

  Thus, we can see that the algorithm is correct if, when it starts,
  no \glspl{cell} are marked. As no \glspl{cell} are marked after it
  completes, this becomes a constraint on the allocator, to unmark
  recycled \glspl{cell} before giving them to the
  \gls{mutator}. It can also be seen from the precondition that the
  \gls{collector} has an overhead of one \gls{cell}: the ``first''
  \gls{cell} is never collected, and so correctness does not strictly
  hold if ``first'' is not reachable, but the \gls{collector} is close
  enough such that it doesn't really matter.
\end{proof}

\subsubsection{Total Correctness}
\label{sec:marksweep-example-total}

We can use allocation IDs to express that the history list forms an
unbroken chain of cells, all the way back to the first cell, as
follows:

\[\forall x,\ \left(x = \mathrm{first} \implies x =
  \mathrm{hist}(x)\right) \land \left(x \neq \mathrm{first} \implies
  \exists n \in \mathbb N_{1},\ \id~x = n +
  \id~\mathrm{hist}(x)\right)\]

The loop condition can be restated as $\id~\mathtt{SCAV} \neq 0$. As
there are no IDs below 0 ($\mathrm{hist}(\mathrm{first}) =
\mathrm{first}$), that can be further rewritten to $\id~\mathtt{SCAV}
> 0$. \texttt{SCAV} starts out as the last-allocated cell, and so has
an ID $\geq 0$. Now, in order to prove termination, we simply need to
show that $\id~\mathtt{SCAV}$ decreases at every iteration of the
loop.

To simplify, let us throw away everything which does not relate to
mutating \texttt{SCAV}, giving the following loop:

\begin{lstlisting}
while (SCAV != first) {
    if (marked(SCAV)) {
        last = SCAV;
        SCAV = hist(last);
    } else {
        SCAV = hist(SCAV);
    }
}
\end{lstlisting}

Substituting variables, we get

\begin{lstlisting}
while (SCAV != first) {
    if (marked(SCAV)) {
        SCAV = hist(SCAV);
    } else {
        SCAV = hist(SCAV);
    }
}
\end{lstlisting}

And then we can eliminate the if statement:

\begin{lstlisting}
while (SCAV != first) {
    SCAV = hist(SCAV);
}
\end{lstlisting}

Trivially, we can now see that there are two cases:

\begin{description}
  \item[Case 1, $\mathtt{SCAV} = \mathrm{first}$] In this case,
    $\mathrm{hist}(\mathtt{SCAV}) = \mathtt{SCAV}$, and so
    $\id~\mathtt{SCAV}$ does not decrease, but this situation is
    precisely the loop termination condition.

  \item[Case 2, $\mathtt{SCAV} \neq \mathrm{first}$] In this case, we
    know by the history list assumption that
    $\id~\mathrm{hist}(\mathtt{SCAV}) < \id~\mathtt{SCAV}$, and so
    $\id~\mathtt{SCAV}$ does decrease. Furthermore, we know that the
    ID cannot decrease below zero, and so we get a strictly decreasing
    sequence of positive natural numbers. Clearly, this sequence is
    not infinite, and so the loop terminates.
\end{description}

\section{Summary}
\label{sec:marksweep-summary}

\todo{Quick recap of formalism, proof obligations, and proof.}