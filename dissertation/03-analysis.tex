\chapter{Problem Analysis}
\label{sec:analysis}

In this chapter I shall discuss how I am going to approach the
project. In Section \ref{sec:analysis-aims} I will discuss the aims,
with some reflection on the literature; in Section
\ref{sec:analysis-formalism} I will discuss how I am going to develop
the formalism; and in Section \ref{sec:analysis-evaluation} I will
discuss how I am going to evaluate the success of my project at the
end.

\section{Aims Revisited}
\label{sec:analysis-aims}

Reviewing the literature reveals that much of the recent work in
garbage collection development has been focused on concurrency, and
obtaining real-time guarantees. The topic of verified garbage
collection has received comparatively little interest, and is perhaps
viewed as something which would be nice in an ideal world, but not as
important as making garbage collectors as fast as possible. This is a
shame, as garbage collection bugs can be a very difficult problem to
detect through testing alone.

There have been a few verified garbage collectors, however these tend
to be proofs for specific extant algorithms, or extraction using very
strict definitions of garbage collection. The former typically cannot,
unfortunately, generalise to other collectors, and the latter makes
generalising to types of collectors other than what the author had in
mind very difficult.

This project explores the route of using generic and flexible
formalisms, not tied to any particular class of collector, and which
can be used for the proof or extraction methods. The aim, through
development and subsequent generalisation of formalisms, is to
produce:

\begin{itemize}
  \item specific formalisms for mark-sweep and copying collectors,
    with proofs of a simple collector of each type;

  \item a generic formalism for garbage collection partial
    correctness, in terms of the postconditions of the collector, and
    any invariants which must hold over the heap;

  \item implementations of the two collectors, with assertions checked
    at key program points.
\end{itemize}

\section{Development Methodology}
\label{sec:analysis-formalism}

I shall develop the formalisms by first defining all of the
necessities (such as the heap, cells, pointers, reachability) and
building everything up from first principles. Then, I shall consider
what it means for a mark-sweep and a copying collector to be correct,
and produce appropriate invariants and postconditions to ensure this.

I shall then unify the two approaches, possibly branching out to
include other properties, in the general formalism, and show how it
could be specialised to the previously-proven collectors.

\section{Evaluation Methodology}
\label{sec:analysis-evaluation}

The specific formalisms shall be evaluated by considering how
convincing the proofs are, and what issues (if any) are raised by the
implementations with checked assertions. To a lesser extend, the
evaluation will also consider how ``easy'' the proofs were. The
implementations shall be evaluated by discussing which properties were
checked, and which others could possibly have been. In addition, the
test mutator will be discussed.

The generic formalism shall be evaluated by considering how different
it is to the specific formalisms, and how easy it was to produce given
them. Furthermore, I shall consider how ``obvious'' an extension it is
of the specific formalisms, such as whether it is just a unification
of the two, or whether it allows anything totally different to what
the two specific formalisms permit.
