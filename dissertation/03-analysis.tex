\chapter{Problem Analysis}
\label{sec:analysis}

In this chapter I shall discuss how I am going to approach the
project. In section \ref{sec:analysis-aims} I will discuss the aims,
with some reflection on the literature; in section
\ref{sec:analysis-development} I will discuss how I am going to
develop the formalism, the algorithm, and prove its correctness with
respect to the formalism; and in section \ref{sec:analysis-evaluation}
I will discuss how I am going to evaluate the success of my project at
the end.

\section{Aims Revisited}
\label{sec:analysis-aims}

Reviewing the literature reveals that much of the recent work in
garbage collection development has been focused on concurrency, and
obtaining real-time guarantees. The topic of verified garbage
collection has received comparatively little interest, and is perhaps
viewed as something which would be nice in an ideal world, but not as
important as making garbage collectors as fast as possible. This is a
shame, as garbage collection bugs can be a very difficult problem to
detect through testing alone.

There have been a few verified garbage collectors, however these tend
to be proofs for specific extant algorithms, or extraction using very
strict definitions of garbage collection. The former typically cannot,
unfortunately, generalise to other collectors, and the latter makes
generalising to types of collectors other than what the author had in
mind very difficult.

This project explores the route of using generic and flexible
formalisms, not tied to any particular class of collector, and which
can be used for the proof or extraction methods. The aim, through
algorithm/formalism co-design, is to produce:

\begin{itemize}
  \item a generic formalism for garbage collection partial
    correctness, in terms of garbage collection as a function applied
    to the program state;

  \item an illustration of the utility of the formalism by proofs of
    correctness of two simple mark-sweep collectors: one specialised
    for immutable languages, and one more general;

  \item design, proof, and implementation of a copying collector.
\end{itemize}

\section{Development Methodology}
\label{sec:analysis-development}

\todo{How I'm going to develop the algorithm and prove it}

\section{Evaluation Methodology}
\label{sec:analysis-evaluation}

The formalism and algorithm shall be evaluated separately.

\subsection{Evaluating the Formalism}
\label{sec:analysis-evaluation-formalism}

The formalism shall be evaluated by considering how well it applies to
a variety of collectors. In this dissertation, only mark-sweep and
copying will be proven, but the proof obligations for other types of
collectors will be examined in order to determine if the formalism is
capable of satisfying them.

Furthermore, what the formalism doesn't state will be discussed, as in
order to make it widely applicable it must abstract over the details
which make each class of collector unique.

Finally, it shall be compared to other formalisms, and the advantages
and disadvantages of it over the others will be discussed.

\subsection{Evaluating the Algorithm}
\label{sec:analysis-evaluation-algorithm}

The algorithm shall be compared to current garbage collection
algorithms, in particular stop-the-world collectors, and the relative
performance and ease of implementation discussed. Whilst performance
is not a primary concern in the project, it would be nice to produce
something of competitive speed.

\subsection{Qualiative Evaluation}
\label{sec:analysis-evaluation-qualitative}

Finally, how ``nice'' the formalism and algorithm are to use will be
considered. The aim of the project is primarily to produce a flexible
and generic formalism, but also to produce a formalism which can be
used to ease the difficulty of proving correctness. Even if the
formalism has everything that could be desired, if it is difficult to
work with, there is scope for improvement.

Similarly, the algorithm should be simplistic and primarily be used to
illustrate the use of the formalism, but it should also be a
realistically viable garbage collection algorithm. Whilst designing
and verifying a concurrent real-time collector is out of scope for
this project, it should still offer something new.

\subsection{Summary}
\label{sec:analysis-summary}

\todo{Summary, once I have written the rest}
