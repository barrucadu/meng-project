\chapter{The Heap as an Array}
\label{sec:heap}

In this chapter I shall explain and justify how the heap can be
modelled as an array, and introduce a specific formalism for reasoning
about array-based programs, along with some examples of its use. This
formalism will be used in later chapters.

In a physical computer, the heap lives in virtual memory, where
virtual memory consists of an integer-indexed collection of machine
words. In the case of x86 computers, these words are bytes, and the
range of addresses allows for 4GiB of virtual memory per
process. Contiguous addresses refer to contiguous heap locations, and
the addressing starts at zero (although this is usually mapped to an
invalid memory location to catch errors).

This sounds rather like a zero-indexed array, and in fact we can
consider the heap to be such an array to allow reasoning. More
abstract formalisms (such as considering the heap to be a digraph) are
possible, and one such alternative (separation logic) shall be
reviewed, however I argue that the array model is the simplest way to
capture the semantics of memory as seen by programs.

In the array formalism, pointers simply become indexes into this
array. We need to be careful about illegal addresses, such as zero,
but by imposing a validity condition upon pointers, such as requiring
they all point to the start of a cell, we can side-step this issue.

\section{The Alternative: Separation Logic}
\label{sec:heap-separation}

Separation logic, introduced by Reynolds in 2002\cite{Reynolds02}, is
an extension of Hoare logic for reasoning about states consisting of a
stack and heap, where the heap is a partial function from addresses to
values. In particular, the logic provides the following extra
predicates to reason about the heap,

\begin{itemize}
  \item $\mathbf{emp}$, the heap is empty;

  \item $e \mapsto e'$, the heap is the singleton heap, where the
    address $e$ maps to the value $e'$;

  \item $P \sepc Q$, the heap can be split into two disjoint partitions
    where $P$ holds in one and $Q$ in the other;

  \item $P \sepi Q$, were the heap to be extended by a disjoint part
    which satisfies $P$, the entire heap would satisfy $Q$.
\end{itemize}

In addition to these operators, there is an additional deduction rule,
allowing modular reasoning about program components,

\begin{prooftree}
  \AxiomC{$\htriple{P}{C}{Q}$}
  \UnaryInfC{$\htriple{P \sepc R}{C}{Q \sepc R}$}
\end{prooftree}

This is known as the frame rule, and is valid if no free variables in
$R$ are modified in $C$. This states that you can take a proof of a
program in a small context, and reuse it in a larger context.

In this formalism pointers are parameters to the partial function
which is the heap, where the heap can be anything. For example, you
could reason about a heap of cells, where pointers are all multiples
of 2. This formalism also allows pointer arithmetic (as does the array
formalism), but reasoning about properties such as reachability is
more difficult in this case.

The main reason I do not use separation logic in this project is
because I will necessarily be reasoning about the entire state, and
there would be very little scope for separation to be of use. Thus,
using separation logic could result in additional complication for
little gain. However, in the case of non-stop-the-world collectors,
the tools of separation logic (or something similar) would undoubtedly
be useful.

\section{Reasoning with Arrays}
\label{sec:heap-arrays}

\todo{Intro to Gries formalism and key points}

\todo{Access axiom}

\todo{Access example: summing a list}

\todo{Assignment axiom}

\todo{Assignment example: doubling every element in a list}

\subsection{The Heap as an Array for Garbage Collection}
\label{sec:heap-arrays-gc}

\todo{Why this makes thinking about gc easy}

\section{Summary}
\label{sec:heap-summary}

\todo{Summary of chapter: key ideas behind Gries, what will need to be
carried forward}
