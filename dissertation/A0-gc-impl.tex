\chapter{Checked Garbage Collector Implementations}
\label{sec:gc-impl}

\lstset{language=C}

\section{Armstrong/Virding}
\label{sec:gc-impl-armstrong-virding}

This is an implementation of the Armstrong/Virding\cite{Armstrong95}
mark-sweep garbage collector for Erlang in C, as used in Section
\ref{sec:results-impl-ms} to demonstrate the validity of assertions
made in Chapter \ref{sec:marksweep}. The functions
\texttt{on\_free\_list}, \texttt{reachable\_from}, \texttt{reachable},
and \texttt{cell\_id} are used solely in assertions, and are not
necessary for a non-instrumented implementation of the collector. The
allocator calls the garbage collector upon running out of space, and
the user cannot call the garbage collector directly.

\vspace{1cm}

\lstset{caption={Implementation of Armstrong/Virding in C}}
\lstset{label=lst:armstrong-virding-c}
\lstinputlisting{../code/armstrong-virding.c}

\lstset{caption={Header file for the Armstrong/Virding C implementation}}
\lstset{label=lst:armstrong-virding-h}
\lstinputlisting{../code/armstrong-virding.h}

\section{Fenichel/Yochelson}
\label{sec:gc-impl-fenichel-yochelson}

This is an implementation of the Fenichel/Yochelson\cite{Fenichel69}
copying garbage collector for Lisp in C, as used in Section
\ref{sec:results-impl-c} to demonstrate the validity of assertions
made in Chapter \ref{sec:copying}. The functions
\texttt{on\_free\_list}, \texttt{reachable\_from}, \texttt{reachable},
and \texttt{check\_pointers\_updated} are used solely in assertion
checking. As with the mark-sweep collector, the allocator calls the
garbage collector directly, and no interface to the collector is
exposed to the user programmer.

\lstset{caption={Implementation of Fenichel/Yochelson in C}}
\lstset{label=lst:fenichel-yochelson-c}
\lstinputlisting{../code/fenichel-yochelson.c}

\lstset{caption={Header file for the Fenichel/Yochelson C implementation}}
\lstset{label=lst:fenichel-yochelson-h}
\lstinputlisting{../code/fenichel-yochelson.h}

\section{Test Program}
\label{sec:gc-impl-test-program}

This is the test mutator used in Section \ref{sec:results-impl} to
check the assertions made about the two types of collector. It
allocates a large number of small and short-lived linked-lists,
causing over two-hundred garbage collections in the very constrained
heap given to it. This single mutator, when combined with the two
provided collectors, results in two test programs.

\lstset{caption={Test program}}
\lstset{label=lst:main-c}
\lstinputlisting{../code/main.c}

This implements a small set of functions for manipulating linked lists
in C with potential garbage collection happening in the midst of
processing. The garbage collector used is controlled by a compiler
macro. The potential for copying collection occurring results in the
code being a little more complex than it would be if the garbage
collector were hidden away in the language runtime, but it should
remain fairly clear.

\lstset{caption={Linked list utilities with swappable GC}}
\lstset{label=lst:lists-c}
\lstinputlisting{../code/lists.c}

\lstset{caption={Header file for the linked list utilities}}
\lstset{label=lst:lists-h}
\lstinputlisting{../code/lists.h}

This Makefile (tested with GNU Make) can be used to compile the two
test programs.

\lstset{caption={Makefile}}
\lstset{label=lst:makefile}
\lstinputlisting[style=makefile]{../code/Makefile}

\section{Shared Code}
\label{sec:gc-impl-shared}

Due to the potential for copying collection to change root pointers,
and due to the necessity for the collectors to be able to accurately
enumerate the roots, it was necessary to implement an abstraction
which would give constant pointers. These utility functions maintain
an array of pointers to roots, available to both the mutator and
collectors.

\lstset{caption={Shared root-management code}}
\lstset{label=lst:shared-c}
\lstinputlisting{../code/shared.c}

\lstset{caption={Definition of cells and shared prototypes}}
\lstset{label=lst:shared-h}
\lstinputlisting{../code/shared.h}
