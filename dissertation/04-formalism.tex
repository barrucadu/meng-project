\chapter{Formalising Garbage Collection}

\section{What Partial Correctness Means}

Myreen starts out by formalising the \gls{heap} as a finite partial
mapping from addresses to \glspl{cell} of \glspl{pointer} and
\gls{data}. He then goes on to define garbage collection as removing
all \gls{garbage} \glspl{cell} from the
\gls{heap}\cite{Myreen10}. This may appear to be quite strict, as not
all \glspl{garbage collector} examine the entire \gls{heap} in every
collection, but I shall show how this can be generalised to other
types of \gls{collector}.

\begin{definition}[Heap]
  The heap is a finite partial mapping, $h$, from addresses (and null) to data:

  \[h : \addr \finparmap \listof{\left(\addr + \nullp\right)} \x \data\]

  We allow null fields in order to store data inside pointers.
\end{definition}

We assume that there is a set $roots$ which contains the \glspl{root}
to be used during \gls{garbage collection}. In practice, this set
would consist of all variables in scope.

\begin{definition}[Reachable]
  All roots are reachable; all cells which can be reached by following
  pointers from the roots are reachable.

  \begin{minipage}{.5\textwidth}
    \begin{prooftree}
      \AxiomC{$r \in roots$}
      \UnaryInfC{$r \in \reach{h}{roots}$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.5\textwidth}
    \begin{prooftree}
      \AxiomC{$r \in \reach{h}{roots}$}
      \AxiomC{$r \pointsto x$}
      \BinaryInfC{$x \in \reach{h}{roots}$}
    \end{prooftree}
  \end{minipage}

  The notation $r \pointsto x$ means that there is a pointer in the
  cell $r$ to the cell $x$.
\end{definition}

\begin{definition}[Garbage]
  A cell is garbage if it is not reachable.

  \begin{prooftree}
    \AxiomC{$x \notin \reach{h}{roots}$}
    \UnaryInfC{$x \in \garbage{h}{roots}$}
  \end{prooftree}
\end{definition}

Now we can formalise what we mean by ``\gls{garbage collection}''. It
is the process of removing from the heap all \glspl{cell} which are
not reachable. We can express this with a domain
restriction. In order to reason about \glspl{collector} which update
addresses (to borrow another idea from Myreen), we also need to allow
addresses to be renamed.

\begin{definition}[Translation]
  Given an injective function $f : \addr \to \addr$, let $\map{f}{x}$
  apply $f$ to every non-null pointer in a cell $x$, and
  $\rename{f}{h}$ update all addresses in a heap $h$ by $f$.

  We now define a relation which performs consistent renaming over the
  entire heap:

  \[(h, roots) \translate \left(\rename{f}{h}, \map{f}{roots}\right)\]
\end{definition}

\begin{definition}[Garbage Collection]
  Garbage collection is the process of removing all garbage cells from
  the heap, and performing a consistent renaming of addresses.

  \[(h, r) \gc (h', r') = (h \restrict \reach{h}{roots}, r) \translate
  (h', r')\]
\end{definition}

In the case of \gls{reference counting} or \gls{mark-sweep} where
\glspl{pointer} are not updated, we can of course use $f = \id$.

\subsection{Less Strict Collectors}

The requirement of removing all \gls{garbage} may appear to be too
strict for some types of collectors, such as generational (which only
look at a part of the heap at a time) or incremental (which only
perform a fixed amount of work each collection), however the formalism
can also be applied to these types of collectors.

\subsubsection{Generational Collectors}

The problem with generational collectors is that we only look at one
generation at a time, and so the heap may contain garbage in other
generations which is not touched. Even worse, there may be
\gls{garbage} in the collected generation, but which is pointed to by
something from an older generation, and so is treated as live! This
latter problem is known as \gls{nepotism}, and is a problem that must
be overcome with \glspl{generational garbage collection}.

We can resolve this problem with two tactics.

\begin{enumerate}
  \item For the correctness of minor collection, regard each
    generation (along with all younger ones) as its own
    \gls{heap}. The \glspl{root} are then the \glspl{root} of the
    computation, plus any inbound \glspl{old-to-young pointer}.

  \item For the correctness of major collection, consider the
    \gls{heap} as a whole.
\end{enumerate}

Generational correctness, then, consists of showing that both the
minor and major collections are correct. Furthermore, if the collector
records young-to-old pointers as well as old-to-young, each generation
can be regarded as its own heap.

\subsubsection{Incremental Collectors}

\Glspl{incremental collector}, similarly to generational collectors, only do
a fixed amount of work each time. However, rather than dividing the
heap up into subheaps, they pick up where they left off at the start
of each collection. When the entire heap has been collected, they
start again at the beginning.

We can envision the collector as being somewhat like this:

\begin{verbatim}
set up the initial collector state

while there is work to be done:
    do a little collection
    do a little mutation

do any finalisation work
\end{verbatim}

Hopefully it can be seen that there is a trivial transformation from
any \gls{incremental collector} to a stop-the-world \gls{collector}:
we simply remove the ``do a little mutation'' step from the
collector. The collector can still be invoked under the same
circumstances as it would be when it was incremental, but now we pause
the \gls{mutator} until all of the collection is done, and then return
control to it.

\section{A Framework for Proof}

In this section, a framework for proving correctness is proposed, as a
series of specific lemmata, which should hopefully be easier to work
with than the abstract formalism of correctness.

Additionally, having such a framework allows us to reason about small
parts of a \gls{garbage collector}, rather the entire thing. It may be
unfeasible to prove correctness for a large and complicated
\gls{collector}, but proving that (for example) \glspl{pointer} are
modified correctly may be enough.

\subsection{Garbage Collection: The Commonalities}

Firstly, we must establish what it is that is common to all
\glspl{garbage collector}. Somewhat trivially, we can see that
\glspl{garbage collector}:

\begin{enumerate}
  \item Partition the \glspl{cell} into cells to keep and cells to
    discard.
  \item Free the cells to be discarded.
  \item Move the cells to be kept.
\end{enumerate}

In the case of non-moving collectors, such as mark-sweep, the last
point is not performed. In the case of moving collectors, such as
mark-compact, the second is not explicitly performed. We can, however,
intuitively see that these three steps are necessary for a garbage
collector to be correct.

Points 1 and 2 are performed by the \gls{heap} domain restriction, and
point 3 is performed by the address translation function.

\subsection{Heap Domain Restriction}

In order to show that the \gls{collector} performs a correct
\gls{heap} domain restriction, we must show that nothing necessary is
freed and no garbage is preserved, and that data fields are
in the same state at the end of collection as they were at the start.

\subsubsection{Cells to be Preserved}

We define a set, $\keep{h}{roots}$ consisting of the set of
\glspl{cell} preserved by the collector.

\begin{lemma}[Nothing live discarded]
  \[\reach{h}{roots} \subseteq \keep{h}{roots}\]
\end{lemma}

\begin{lemma}[No garbage preserved]
  \[\garbage{h}{roots} \cap \keep{h}{roots} = \emptyset\]

  It may be easier to prove the equivalent, reformulated, version:

  \[\keep{h}{roots} \subseteq \reach{h}{roots}\]
\end{lemma}

It should be very easy to see that proving these two lemmata shows
that $\keep{h}{roots} = \reach{h}{roots}$.

\subsubsection{Invariance of Data}

The only operations performed by the abstract collector are removing
garbage cells and renaming \glspl{pointer}; there is no room for
modifying data, or modifying \glspl{pointer} outside of the
translation function (but that will be covered in the next
subsection).

Thus, we also need to show:

\begin{lemma}[Data is unmodified]
\end{lemma}

\begin{lemma}[Null pointers remain null]
\end{lemma}

\subsection{Address Translation}

The second operation which the abstract \gls{collector} performs is a
consistent renaming of \glspl{pointer} across the entire
\gls{heap}. In order to reason about this, we must extract the
\gls{pointer} renaming portion of the \gls{garbage collector} under
consideration.

We shall call this translation function $f$.

\subsubsection{Consistency of Translation Function}

Fundamentally, we need the translation function to be consistent. It
cannot merge two addresses. It cannot throw any addresses
away. Furthermore, it must (trivially) be from the set of addresses to
the set of addresses.

We can express all of these with two requirements,

\begin{lemma}[$f$ must be a function]
  If $f$ is a function, then every address maps to one other address.

  \[\forall a : \addr,\ \exists ! b : \addr,\ (a, b) \in f\]
\end{lemma}

\begin{lemma}[$f$ must be injective]
  If $f$ is injective, then every pair of unique addresses map to
  unique addresses.

  \[\forall a, b \in \dom~f,\ f(a) = f(b) \iff a = b\]
\end{lemma}

\subsubsection{Consistency of Function Application}

Finally, we need to show that $f$ is applied consistently across the
entire \gls{heap}. We can separate this into thinking about the
\gls{root} set and the live \gls{heap}

\begin{lemma}[Roots are remapped]
  Specifically, the roots are remapped, no new roots are introduced,
  and no roots are thrown away:

  \[roots' = \map{f}{roots}\]
\end{lemma}

\begin{lemma}[Heap is remapped]
  As address remapping is done after the domain restriction, we only
  need to concern ourselves with live cells here:

  \[h' \restrict \keep{h'}{roots'} = \rename{f}{h \restrict \keep{h}{roots}}\]
\end{lemma}

\subsection{Sufficiency of the Framework}

We now show that the lemmata, together, show that a relation is a
garbage collection relation.

\begin{theorem}[Heap Domain Restriction]
  Firstly, we must show that only those cells which are live are
  preserved by the domain restriction.

  \begin{align*}
    \keep{h}{roots} &\subseteq \reach{h}{roots} & \mbox{lemma 1}\\
    \reach{h}{roots} &\subseteq \keep{h}{roots} & \mbox{lemma 2}\\
    \therefore \keep{h}{roots} &= \reach{h}{roots}
  \end{align*}

  As lemmata 3 and 4 show that data is not modified, we can simply state,

  \[h' = h \restrict \reach{h}{roots}\]
\end{theorem}

\begin{theorem}[Address Translation]
  Given lemmata 5 and 6, $f$ is a consistent renaming function, and so
  we simply need to show that we can deduce a translation relation. We
  can see from lemma 8 that there is no garbage in the resultant heap:

  \begin{align*}
    h' \restrict \keep{h'}{roots'} &= \rename{f}{h \restrict
      \keep{h}{roots}} &\mbox {lemma 8}\\
    &= h' & \mbox{rename}
  \end{align*}

  We can now consider the moving/renaming part of the garbage
  collector as a whole:

  \begin{align*}
    (h, r) \to (h', r') &= (h, r) \to \left(\rename{f}{h \restrict
        \keep{h}{roots}}, \map{f}{r}\right) & \mbox{lemma 7}\\
    &= (h \restrict \keep{h}{roots}, r) \translate (h', r') &\mbox{translate}
  \end{align*}
\end{theorem}

Now these two results can be put together to show correct garbage
collection.

\begin{theorem}[Sufficiency of Framework]
  \begin{align*}
    (h, r) \to (h', r') &= (h \restrict \keep{h}{roots}, r) \translate
    (h', r') & \mbox{thm. 2}\\
    &= (h \restrict \reach{h}{roots}, r) \translate (h', r') &
    \mbox{thm. 1}\\
    &= (h, r) \gc (h', r') &\mbox{gc}
  \end{align*}
\end{theorem}

\section{Correctness of Mark-Sweep Collectors}

\todo{Show how proof framework can be specialised for the case of
  mark-sweep collectors}

\subsection{For Immutable Languages}

\todo{Proof of correctness of the Erlang collector}

\subsection{For Mutable Languages}

\todo{Proof of correctness of the Runciman collector}