\chapter{Formalising Garbage Collection}

\section{What Partial Correctness Means}

Myreen starts out by formalising the \gls{heap} as a finite partial
mapping from addresses to \glspl{cell} of \glspl{pointer} and
\gls{data}. He then goes on to define garbage collection as removing
all \gls{garbage} \glspl{cell} from the
\gls{heap}\cite{Myreen10}. This may appear to be quite strict, as not
all \glspl{garbage collector} examine the entire \gls{heap} in every
collection, but I shall show how this can be generalised to other
types of \gls{collector}.

\begin{definition}[Heap]
  The heap is a finite partial mapping, $h$, from addresses (and null) to data:

  \[h : \addr \finparmap \listof{\left(\addr + \nullp\right)} \x \data\]

  We allow null fields in order to store data inside pointers.
\end{definition}

We assume that there is a set $roots$ which contains the \glspl{root}
to be used during \gls{garbage collection}. In practice, this set
would consist of all variables in scope.

\begin{definition}[Reachable]
  All roots are reachable; all cells which can be reached by following
  pointers from the roots are reachable.

  \begin{minipage}{.5\textwidth}
    \begin{prooftree}
      \AxiomC{$r \in roots$}
      \UnaryInfC{$r \in \reach{h}{roots}$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{.5\textwidth}
    \begin{prooftree}
      \AxiomC{$r \in \reach{h}{roots}$}
      \AxiomC{$r \pointsto x$}
      \BinaryInfC{$x \in \reach{h}{roots}$}
    \end{prooftree}
  \end{minipage}

  The notation $r \pointsto x$ means that there is a pointer in the
  cell $r$ to the cell $x$.
\end{definition}

\begin{definition}[Garbage]
  A cell is garbage if it is not reachable.

  \begin{prooftree}
    \AxiomC{$x \notin \reach{h}{roots}$}
    \UnaryInfC{$x \in \garbage{h}{roots}$}
  \end{prooftree}
\end{definition}

Now we can formalise what we mean by ``\gls{garbage collection}''. It
is the process of removing from the heap all \glspl{cell} which are
not reachable. We can express this with a domain
restriction. In order to reason about \glspl{collector} which update
addresses (to borrow another idea from Myreen), we also need to allow
addresses to be renamed.

\begin{definition}[Translation]
  Given a function $f : \addr \to \addr$, let $\map{f}{x}$ apply $f$
  to every non-null pointer in a cell $x$, and $\rename{f}{h}$ update
  all addresses in a heap $h$ by $f$.

  We now define a relation which performs consistent renaming over the
  entire heap:

  \begin{prooftree}
    \AxiomC{$f \of f = \id$}
    \UnaryInfC{$(h, roots) \translate \left(\rename{f}{h},
        \map{f}{roots}\right)$}
  \end{prooftree}
\end{definition}

\begin{definition}[Garbage Collection]
  Garbage collection is the process of removing all garbage cells from
  the heap, and performing a consistent renaming of addresses.

  \[(h, r) \gc (h', r') = (h \restrict \reach{h}{roots}, r) \translate
  (h', r')\]
\end{definition}

In the case of \gls{reference counting} or \gls{mark-sweep} where
\glspl{pointer} are not updated, we can of course use $f = \id$.

\subsection{Less Strict Collectors}

The requirement of removing all \gls{garbage} may appear to be too
strict for some types of collectors, such as generational (which only
look at a part of the heap at a time) or incremental (which only
perform a fixed amount of work each collection), however the formalism
can also be applied to these types of collectors.

\subsubsection{Generational Collectors}

The problem with generational collectors is that we only look at one
generation at a time, and so the heap may contain garbage in other
generations which is not touched. Even worse, there may be
\gls{garbage} in the collected generation, but which is pointed to by
something from an older generation, and so is treated as live! This
latter problem is known as \gls{nepotism}, and is a problem that must
be overcome with \glspl{generational garbage collection}.

We can resolve this problem with two tactics.

\begin{enumerate}
  \item For the correctness of minor collection, regard each
    generation (along with all younger ones) as its own
    \gls{heap}. The \glspl{root} are then the \glspl{root} of the
    computation, plus any inbound \glspl{old-to-young pointer}.

  \item For the correctness of major collection, consider the
    \gls{heap} as a whole.
\end{enumerate}

Generational correctness, then, consists of showing that both the
minor and major collections are correct. Furthermore, if the collector
records young-to-old pointers as well as old-to-young, each generation
can be regarded as its own heap.

\subsubsection{Incremental Collectors}

\section{Correctness of a Mark-Sweep Collector for Immutable
  Languages}

\todo{Proof of correctness of the Erlang collector}

\section{Correctness of a Mark-Sweep Collector for Mutable Languages}

\todo{Proof of correctness of the Runciman collector}