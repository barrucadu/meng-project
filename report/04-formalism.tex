\chapter{Formalising Garbage Collection}

\section{What Partial Correctness Means}

To precisely formalise garbage collection, we must first informally
determine what the whole process is about. Myreen\cite{Myreen10}
starts by defining the heap as a finite partial mapping from addresses
to a list of pointers and some data. He then proceeds to formalise
garbage collection as a state isomorphism with no garbage cells left
over, however this is a rather strict definition.

\begin{definition}[Garbage (informal)]
  A cell is called garbage if it is not reachable by following a chain
  of pointers from the variables currently in scope.
\end{definition}

Now that we know what garbage is, we can start talking about what we
mean by collecting it.

\begin{definition}[Weak Garbage Collection (informal)]
  A garbage collector satisfies the weak garbage collection property
  if it is a state isomorphism, where the number of garbage cells in
  the resultant heap is no greater than in the original heap.
\end{definition}

This may not appear to be terribly useful, but in some cases it is the
strongest statement we can make. For example, in the case of
generational garbage collection, the nepotism effect (tenured garbage
cells pointing to cells in the younger generation) may cause some
cells which are, strictly speaking, garbage to survive a minor
collection. These cells are then collected whenever there is a major
collection, but to say that a generational collects only ``collects''
when the entire heap is examined would be a very strange use of
terminology.

\begin{definition}[Strong Garbage Collection (informal)]
  A garbage collector satisfies the strong garbage collection property
  if it is a state isomorphism, where the number of garbage cells in
  the resultant heap is strictly less than in the original heap.
\end{definition}

This is a slightly relaxed version of Myreen's statement, which is
suitable for collectors which only do a fixed amount of work at each
collection, rather than examining the entire heap. This is common for
collectors which try to impose a bound on pause times, but (more
generally) is a property of any incremental collector.

\subsection{Logic}

\todo{Introduction of the logic being used in the project. Restatement
of the English formalisms in the logic.}

\section{Correctness of a Mark-Sweep Collector for Immutable
  Languages}

\todo{Proof of correctness of the Erlang collector}

\section{Correctness of a Mark-Sweep Collector for Mutable Languages}

\todo{Proof of correctness of the Runciman collector}