* Reducing Generational Copy Reserve Overhead with Fallback Compaction
- Authors :: Phil McGachey and Antony L. Hosking
- Year    :: 2006
- Source  :: ISMM

As programming languages with managed runtimes become increasingly popular, it is essential that virtual machines are implemented efficiently. The performance of the memory management subsystem can be a defining factor in the performance of the virtual machine as a whole. We present a technique by which garbage collector performance can be improved.

We describe an algorithm that combines a standard generational copying collector with a mark and compact collector. We observe that, since most objects do not survive a garbage collection, it is not necessary to reserve space to copy them all. The result is a generational copying collector with a smaller copy reserve overhead than traditional Appel-style collectors. We maintain correctness in the worst case through the use of mark and compact collection. When the reduced copy reserve overflows, a compacting phase ensures that all data are accommodated.

We have implemented this algorithm within the framework of Jikes RVM and MMTk. For most benchmarks examined, our experiments show that the performance is comparable to or better than a standard generational copying collector.

** Summary
The authors note that the worst case of a generational collector, everything surviving a minor collection, is very rare, and so a copy reserve large enough to hold every object is not necessary normally. Thus, a much smaller copy reserve is used, in order to give more usable space to the system. This has the effect of reducing the frequency of collections. However, the worst case still remains and must be accounted for. In the case where the copy reserve fills, the copying collector is aborted, and a mark-compact collector is invoked to collect the rest of the younger generation.

** Relevance to Project
Not directly relevant, but a possible indication of how the state of the art has progressed.

** References
- Jones & Lins 96 :: Garbage Collection: Algorithms for Automatic Dynamic Memory Management
- Lieberman & Hewitt 83 :: A Real-Time Garbage Collector Based on the Lifetimes of Objects
- [[file:Generation%20Scavenging:%20A%20Non-disruptive%20High%20Performance%20Storage%20Reclamation%20Algorithm.org][Ungar 84 :: Generation Scavenging: A Non-Disruptive High Performance Storage Reclamation Algorithm]]
- Backburn, Jones, McKinley & Moss 02 :: Beltway: Getting Around Garbage Collection Gridlock
- [[file:Simple%20Generational%20Garbage%20Collection%20and%20Fast%20Allocation.org][Appel 89 :: Simple Generational Garbage Collection and Fast Allocation]]
- Cohen & Nicholau 83 :: Comparison of Compacting Algorithms for Garbage Collection
- Haddon & Waite 67 :: A Compaction Procedure for Variable Length Storage Elements
- Fisher 75 :: Bounded Workspace Garbage Collection in an Address Order Preserving List Processing Environment
- Wilson 95 :: Uniprocessor Garbage Collection Techniques
- Jonkers 79 :: A Fast Garbage Collection Algorithm
- Velasco, Ortiz, Olcoz & Tirado 04 :: Adaptive Tuning of Reserved Space in an Appel Collector
- Sachindran, Moss & Berger 04 :: MC²: High-Performance Garbage Collection for Memory-Constrained Environments
- Printezis 01 :: Hot-Swapping Between a Mark&Sweep and a Mark&Compact Garbage Collector in a Generational Environment
- Soman, Krintz & Bacon 04 :: Dynamic Selection of Application-Specific Garbage Collectors
- Blackburn, Cheng & McKinley 04 :: Oil and Water? High Performance Garbage Collection in Java with MMTk
- Alpern et al. 99 :: Implementing Jalapeño in Java
- Baker 92 :: The Treadmill: Real-TIme Garbage Collection Without Motion Sickness
